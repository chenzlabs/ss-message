import debuglog from 'debug-levels';
import lang from 'bot-lang';
import Utils from './util';

const debug = debuglog('SS:Message');


// The message could be generated by a reply or raw input
// If it is a reply, we want to save the ID so we can filter them out if said again
class Message {
  /**
   * Creates a new Message object.
   * @param {String} message - The cleaned message.
   * @param {Object} options - The parameters.
   * @param {String} options.original - The original message text.
   * @param {Object} options.factSystem - The fact system to use.
   * @param {String} [options.replyId] - If the message is based on a reply.
   * @param {String} [options.clearConversation] - If you want to clear the conversation.
   */
  constructor(message, options) {
    debug.verbose(`Creating message from string: ${message}`);

    this.id = Utils.genId();

    // If this message is based on a Reply.
    if (options.replyId) {
      this.replyId = options.replyId;
    }

    if (options.clearConversation) {
      this.clearConversation = options.clearConversation;
    }

    this.factSystem = options.factSystem;
    this.createdAt = new Date();

    // This version of the message is `EXACTLY AS WRITTEN` by the user
    this.original = message;

    this.raw = lang.replace.all(message).trim();
    this.clean = Utils.cleanMessage(this.raw).trim();
    
    debug.verbose('Message before cleaning: ', message);
    debug.verbose('Message after cleaning: ', this.clean);

    this.props = {};
  }

  static createMessage(message, options, callback) {
    if (!message) {
      debug.verbose('Message received was empty, callback immediately');
      return callback({});
    }

    const messageObj = new Message(message, options);
    messageObj.finishCreating(callback);
  }

  finishCreating(callback) {
    callback()
  }
}

export default Message;
